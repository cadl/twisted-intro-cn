<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第十七部分 构造”回调”的另一种方法 &mdash; Twisted 入门|Twisted Introduction</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="top" title="Twisted 入门|Twisted Introduction" href="index.html" />
    <link rel="next" title="第十八部分 Deferreds 全貌" href="p18.html" />
    <link rel="prev" title="第十六部分 Twisted 进程守护" href="p16.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Twisted Introduction</span></a></h1>
        <h2 class="heading"><span>第十七部分 构造”回调”的另一种方法</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="p16.html">第十六部分 Twisted 进程守护</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">目录</a>
        &#160;&#160;::&#160;&#160;
        <a href="p18.html">第十八部分 Deferreds 全貌</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="id1">
<h1>第十七部分 构造&#8221;回调&#8221;的另一种方法<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>你可以从&#8221;<a class="reference internal" href="p01.html"><em>第一部分 Twist理论基础</em></a>&#8220;开始阅读；也可以浏览&#8221;<a class="reference internal" href="index.html"><em>Twisted 入门!</em></a>&#8220;的索引</p>
<div class="section" id="id2">
<h2>简介<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>这部分我们将回到&#8221;回调&#8221;这个主题.我们将介绍另外一种写回调函数的方法,即在Twisted中使用 <a class="reference external" href="http://docs.python.org/tutorial/classes.html#generators">generators</a>. 我们将演示如何使用这种方法并且与使用&#8221;纯&#8221; <tt class="docutils literal"><span class="pre">Deferreds</span></tt> 进行对比. 最后, 我们将使用这种技术重写诗歌客户端. 但首先我们来回顾一下 <tt class="docutils literal"><span class="pre">generators</span></tt> 的工作原理,以便弄清楚它为何是创建回调的候选方法.</p>
<div class="section" id="id3">
<h3>简要回顾生成器<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>你可能知道, 一个Python生成器是一个&#8221;可重启的函数&#8221;,它是在函数体中用 <tt class="docutils literal"><span class="pre">yield</span></tt> 语句创建的. 这样做可以使这个函数变成一个&#8221;生成器函数&#8221;,它返回一个&#8221;<a class="reference external" href="http://docs.python.org/tutorial/classes.html#iterators">iterator</a>&#8220;可以用来以一系列步骤运行这个函数. 每个迭代循环都会重启这个函数,继续执行到下一个 <tt class="docutils literal"><span class="pre">yield</span></tt> 语句.</p>
<p>生成器(和迭代器)通常被用来代表以惰性方式创建的值序列. 看一下以下文件中的代码 <a class="reference external" href="https://github.com/jdavisp3/twisted-intro/blob/master/inline-callbacks/gen-1.py#L1">inline-callbacks/gen-1.py</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">my_generator</span><span class="p">():</span>
    <span class="k">print</span> <span class="s">&#39;starting up&#39;</span>
    <span class="k">yield</span> <span class="mi">1</span>
    <span class="k">print</span> <span class="s">&quot;workin&#39;&quot;</span>
    <span class="k">yield</span> <span class="mi">2</span>
    <span class="k">print</span> <span class="s">&quot;still workin&#39;&quot;</span>
    <span class="k">yield</span> <span class="mi">3</span>
    <span class="k">print</span> <span class="s">&#39;done&#39;</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">my_generator</span><span class="p">():</span>
    <span class="k">print</span> <span class="n">n</span>
</pre></div>
</div>
<p>这里我们用生成器创建了1,2,3序列. 如果你运行这些代码,会看到在生成器上做迭代时,生成器中的 <tt class="docutils literal"><span class="pre">print</span></tt> 与循环语句中的 <tt class="docutils literal"><span class="pre">print</span></tt> 语句交错出现.</p>
<p>以下自定义迭代器代码使上面的说法更加明显(<a class="reference external" href="https://github.com/jdavisp3/twisted-intro/blob/master/inline-callbacks/gen-2.py#L1">inline-callbacks/gen-2.py</a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">my_generator</span><span class="p">():</span>
    <span class="k">print</span> <span class="s">&#39;starting up&#39;</span>
    <span class="k">yield</span> <span class="mi">1</span>
    <span class="k">print</span> <span class="s">&quot;workin&#39;&quot;</span>
    <span class="k">yield</span> <span class="mi">2</span>
    <span class="k">print</span> <span class="s">&quot;still workin&#39;&quot;</span>
    <span class="k">yield</span> <span class="mi">3</span>
    <span class="k">print</span> <span class="s">&#39;done&#39;</span>

<span class="n">gen</span> <span class="o">=</span> <span class="n">my_generator</span><span class="p">()</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">n</span>
</pre></div>
</div>
<p>视作一个序列,生成器仅仅是获取连续值的一个对象.但我们也可以以生成器本身的角度看问题:</p>
<ol class="arabic simple">
<li>生成器函数在被循环调用之前并没有执行(使用 <tt class="docutils literal"><span class="pre">next</span></tt> 方法).</li>
<li>一旦生成器开始运行,它将一直执行直到返回&#8221;循环&#8221;(使用 <tt class="docutils literal"><span class="pre">yield</span></tt>)</li>
<li>当循环中运行其他代码时(如 <tt class="docutils literal"><span class="pre">print</span></tt> 语句),生成器则没有运行.</li>
<li>当生成器运行时, 则循环没有运行(等待生成器返回前它被&#8221;阻滞&#8221;了).</li>
<li>一旦生成器将控制交还到循环,再启动需要等待任意可能时间(其间任意量的代码可能被执行).</li>
</ol>
<p>这与异步系统中的回调工作方式非常类似. 我们可以把 <tt class="docutils literal"><span class="pre">while</span></tt> 循环视作 <tt class="docutils literal"><span class="pre">reactor</span></tt>, 把生成器视作一系列由 <tt class="docutils literal"><span class="pre">yield</span></tt> 语句分隔的回调函数. 有趣的是, 所有的回调分享相同的局部变量名空间, 而且名空间在不同回调中保持一致.</p>
<p>进一步,你可以一次激活多个生成器(参考例子 <a class="reference external" href="https://github.com/jdavisp3/twisted-intro/blob/master/inline-callbacks/gen-3.py#L1">inline-callbacks/gen-3.py</a>),使得它们的&#8221;回调&#8221;互相交错,就像在Twisted系统中独立运行的异步程序.</p>
<p>然而,这种方法还是有一些欠缺.回调不仅仅被 <tt class="docutils literal"><span class="pre">reactor</span></tt> 调用, 它还能接受信息.作为 <tt class="docutils literal"><span class="pre">deferred</span></tt> 链的一部分,回调要么接收Python值形式的一个结果,要么接收 <tt class="docutils literal"><span class="pre">Failure</span></tt> 形式的一个错误.</p>
<p>从Python2.5开始,生成器功能被扩展了.当你再次启动生成器时,可以给它发送信息,如 <a class="reference external" href="https://github.com/jdavisp3/twisted-intro/blob/master/inline-callbacks/gen-4.py#L1">inline-callbacks/gen-4.py</a> 所示:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Malfunction</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">my_generator</span><span class="p">():</span>
    <span class="k">print</span> <span class="s">&#39;starting up&#39;</span>

    <span class="n">val</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">1</span>
    <span class="k">print</span> <span class="s">&#39;got:&#39;</span><span class="p">,</span> <span class="n">val</span>

    <span class="n">val</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">2</span>
    <span class="k">print</span> <span class="s">&#39;got:&#39;</span><span class="p">,</span> <span class="n">val</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="mi">3</span>
    <span class="k">except</span> <span class="n">Malfunction</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;malfunction!&#39;</span>

    <span class="k">yield</span> <span class="mi">4</span>

    <span class="k">print</span> <span class="s">&#39;done&#39;</span>

<span class="n">gen</span> <span class="o">=</span> <span class="n">my_generator</span><span class="p">()</span>

<span class="k">print</span> <span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span> <span class="c"># start the generator</span>
<span class="k">print</span> <span class="n">gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c"># send the value 10</span>
<span class="k">print</span> <span class="n">gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="c"># send the value 20</span>
<span class="k">print</span> <span class="n">gen</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="n">Malfunction</span><span class="p">())</span> <span class="c"># raise an exception inside the generator</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>在Python2.5以后的版本中, <tt class="docutils literal"><span class="pre">yield</span></tt> 语句是一个计算值的表达式.重新启动生成器的代码可以使用 <tt class="docutils literal"><span class="pre">send</span></tt> 方法代替 <tt class="docutils literal"><span class="pre">next</span></tt> 决定它的值(如果使用 <tt class="docutils literal"><span class="pre">next</span></tt> 则值为 <cite>None</cite>), 而且你还可以在迭代器内部使用 <tt class="docutils literal"><span class="pre">throw</span></tt> 方法抛出任何异常. 是不是很酷?</p>
</div>
<div class="section" id="id4">
<h3>内联回调<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>根据我们刚刚回顾的可以向生成器发送值或抛出异常的特性,可以设想它是像 <tt class="docutils literal"><span class="pre">deferred</span></tt> 中的一系列回调,即可以接收结果或错误. 每个回调被 <tt class="docutils literal"><span class="pre">yield</span></tt> 分隔,每一个 <tt class="docutils literal"><span class="pre">yield</span></tt> 表达式的值是下一个回调的结果(或者 <tt class="docutils literal"><span class="pre">yield</span></tt> 抛出异常表示错误).图35显示相应概念:</p>
<div class="figure" id="figure35">
<img alt="_images/p17_generator-callbacks1.png" src="_images/p17_generator-callbacks1.png" />
</div>
<div class="line-block">
<div class="line">图35:作为回调序列的生成器</div>
</div>
<p>现在一系列回调以 <tt class="docutils literal"><span class="pre">deferred</span></tt> 方式被链接在一起,每个回调从它前面的回调接收结果.生成器很容易做到这一点——当再次启动生成器时,仅仅使用 <tt class="docutils literal"><span class="pre">send</span></tt> 发送上一次调用生成器的结果( <tt class="docutils literal"><span class="pre">yield</span></tt> 产生的值).但这看起来有点笨,既然生成器从开始就计算这个值,为什么还需要把它发送回来? 生成器可以将这个值储存在一个变量中供下一次使用. 因此这到底是为什么呢?</p>
<p>回忆一下我们在 <a class="reference internal" href="p13.html"><em>第十三部分 使用Deferred新功能实现新客户端</em></a> 中所学, <tt class="docutils literal"><span class="pre">deferred</span></tt> 中的回调还可以返回 <tt class="docutils literal"><span class="pre">deferred</span></tt> 本身. 在这种情况下, 外层的 <tt class="docutils literal"><span class="pre">deferred</span></tt> 先暂停等待内层的 <tt class="docutils literal"><span class="pre">deferred</span></tt> 激发,接下来外层 <tt class="docutils literal"><span class="pre">deferred</span></tt> 链使用内层 <tt class="docutils literal"><span class="pre">deferred</span></tt> 的返回结果(或错误)激发后续的回调(或错误回调).</p>
<p>所以设想我们的生成器生成一个 <tt class="docutils literal"><span class="pre">deferred</span></tt> 对象而不是一个普通的Python值. 这时生成器会自动&#8221;暂停&#8221;;生成器总是在每个 <tt class="docutils literal"><span class="pre">yield</span></tt> 语句后暂停直到被显示的重启.因而我们可以延迟它的重启直到 <tt class="docutils literal"><span class="pre">deferred</span></tt> 被激发, 届时我们会使用 <tt class="docutils literal"><span class="pre">send</span></tt> 方法发送值(如果 <tt class="docutils literal"><span class="pre">deferred</span></tt> 成功)或者抛出异常(如果 <tt class="docutils literal"><span class="pre">deferred</span></tt> 失败).这就使我们的生成器成为一个真正的异步回调序列,这正是 <a class="reference external" href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-10.1.0/twisted/internet/defer.py">twisted.internet.defer</a> 中 <a class="reference external" href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-10.1.0/twisted/internet/defer.py#L973">inlineCallbacks</a> 函数背后的概念.</p>
</div>
</div>
<div class="section" id="id5">
<h2>进一步讨论内联回调<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>考虑以下例程, 位于 <a class="reference external" href="https://github.com/jdavisp3/twisted-intro/blob/master/inline-callbacks/inline-callbacks-1.py#L1">inline-callbacks/inline-callbacks-1.py</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">twisted.internet.defer</span> <span class="kn">import</span> <span class="n">inlineCallbacks</span><span class="p">,</span> <span class="n">Deferred</span>

<span class="nd">@inlineCallbacks</span>
<span class="k">def</span> <span class="nf">my_callbacks</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">twisted.internet</span> <span class="kn">import</span> <span class="n">reactor</span>

    <span class="k">print</span> <span class="s">&#39;first callback&#39;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">1</span> <span class="c"># yielded values that aren&#39;t deferred come right back</span>

    <span class="k">print</span> <span class="s">&#39;second callback got&#39;</span><span class="p">,</span> <span class="n">result</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">Deferred</span><span class="p">()</span>
    <span class="n">reactor</span><span class="o">.</span><span class="n">callLater</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">callback</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">d</span> <span class="c"># yielded deferreds will pause the generator</span>

    <span class="k">print</span> <span class="s">&#39;third callback got&#39;</span><span class="p">,</span> <span class="n">result</span> <span class="c"># the result of the deferred</span>

    <span class="n">d</span> <span class="o">=</span> <span class="n">Deferred</span><span class="p">()</span>
    <span class="n">reactor</span><span class="o">.</span><span class="n">callLater</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">errback</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">d</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">e</span>

    <span class="k">print</span> <span class="s">&#39;fourth callback got&#39;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="c"># the exception from the deferred</span>

    <span class="n">reactor</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="kn">from</span> <span class="nn">twisted.internet</span> <span class="kn">import</span> <span class="n">reactor</span>
<span class="n">reactor</span><span class="o">.</span><span class="n">callWhenRunning</span><span class="p">(</span><span class="n">my_callbacks</span><span class="p">)</span>
<span class="n">reactor</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>运行这个例子可以看到生成器运行到最后并终止了 <tt class="docutils literal"><span class="pre">reactor</span></tt>, 这个例子展示了 <tt class="docutils literal"><span class="pre">inlineCallbacks</span></tt> 函数的很多方面.首先, <tt class="docutils literal"><span class="pre">inlineCallbacks</span></tt> 是一个修饰符,它总是修饰生成器函数,如那些使用 <tt class="docutils literal"><span class="pre">yield</span></tt> 语句的函数. <tt class="docutils literal"><span class="pre">inlineCallbacks</span></tt> 的全部目的是将一个生成器按照上述策略转化为一系列异步回调.</p>
<p>第二,当我们调用一个用 <tt class="docutils literal"><span class="pre">inlineCallbacks</span></tt> 修饰的函数时,不需要自己调用 <tt class="docutils literal"><span class="pre">send</span></tt> 或 <tt class="docutils literal"><span class="pre">throw</span></tt> 方法.修饰符会帮助我们处理细节,并确保生成器运行到结束(假设它不抛出异常).</p>
<p>第三,如果我们从生成器生成一个非延迟值,它将以 <tt class="docutils literal"><span class="pre">yield</span></tt> 生成的值立即重启.</p>
<p>最后,如果我们从生成器生成一个 <tt class="docutils literal"><span class="pre">deferred</span></tt>,它不会重启除非此 <tt class="docutils literal"><span class="pre">deferred</span></tt> 被激发.如果 <tt class="docutils literal"><span class="pre">deferred</span></tt> 成功返回,则 <tt class="docutils literal"><span class="pre">yield</span></tt> 的结果就是 <tt class="docutils literal"><span class="pre">deferred</span></tt> 的结果.如果 <tt class="docutils literal"><span class="pre">deferred</span></tt> 失败了,则 <tt class="docutils literal"><span class="pre">yield</span></tt> 会抛出异常. 注这个异常仅仅是一个普通的 <tt class="docutils literal"><span class="pre">Exception</span></tt> 对象,而不是 <tt class="docutils literal"><span class="pre">Failure</span></tt>,我们可以在 <tt class="docutils literal"><span class="pre">yield</span></tt> 外面用 <tt class="docutils literal"><span class="pre">try/except</span></tt> 块捕获它们.</p>
<p>在上面的例子中,我们仅用 <tt class="docutils literal"><span class="pre">callLater</span></tt> 在一小段时间之后去激发 <tt class="docutils literal"><span class="pre">deferred</span></tt>.虽然这是一种将非阻塞延迟放入回调链的实用方法,但通常我们会生成一个 <tt class="docutils literal"><span class="pre">deferred</span></tt>,它是被生成器中其他的异步操作(如 <cite>get_poetry</cite>)返回的.</p>
<p>OK,现在我们知道了 <tt class="docutils literal"><span class="pre">inlineCallbacks</span></tt> 修饰的函数是如何运行的,但当你实际调用时会返回什么值呢?正如你认为的,将得到 <tt class="docutils literal"><span class="pre">deferred</span></tt>.由于不能确切地知道生成器何时停止(它可能生成一个或多个 <tt class="docutils literal"><span class="pre">deferred</span></tt>),装饰函数本身是异步的,所以 <tt class="docutils literal"><span class="pre">deferred</span></tt> 是一个合适的返回值.注:这个返回的 <tt class="docutils literal"><span class="pre">deferred</span></tt> 不是生成器中 <tt class="docutils literal"><span class="pre">yield</span></tt> 生成的 <tt class="docutils literal"><span class="pre">deferred</span></tt>.相反,它在生成器完全结束(或抛出异常)后才被激发.</p>
<p>如果生成器抛出一个异常,那么返回的 <tt class="docutils literal"><span class="pre">deferred</span></tt> 将激发它的错误回调链,把异常包含在一个 <tt class="docutils literal"><span class="pre">Failure</span></tt> 中. 但是如果我们希望生成器返回一个正常值,必须使用 <tt class="docutils literal"><span class="pre">defer.returnValue</span></tt> 函数. 就像普通 <tt class="docutils literal"><span class="pre">return</span></tt> 语句一样,它也会终止生成器(实际会抛出一个特殊异常).例子 <a class="reference external" href="https://github.com/jdavisp3/twisted-intro/blob/master/inline-callbacks/inline-callbacks-2.py#L1">inline-callbacks/inline-callbacks-2.py</a> 说明了这两种可能.</p>
<div class="section" id="id6">
<h3>客户端7.0<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>让我们在新版本的诗歌客户端中加入 <tt class="docutils literal"><span class="pre">inlineCallbacks</span></tt>,你可以在 <a class="reference external" href="https://github.com/jdavisp3/twisted-intro/blob/master/twisted-client-7/get-poetry.py#L1">twisted-client-7/get-poetry.py</a> 中查看源代码.也许你需要与客户端6.0—— <a class="reference external" href="https://github.com/jdavisp3/twisted-intro/blob/master/twisted-client-6/get-poetry.py#L151">twisted-client-6/get-poetry.py</a> 进行对比,它们的相对变化位于 <a class="reference external" href="https://github.com/jdavisp3/twisted-intro/blob/master/twisted-client-7/get-poetry.py#L151">poetry_main</a>:</p>
<div class="highlight-python"><pre>def poetry_main():
    addresses = parse_args()

    xform_addr = addresses.pop(0)

    proxy = TransformProxy(*xform_addr)

    from twisted.internet import reactor

    results = []

    @defer.inlineCallbacks
    def get_transformed_poem(host, port):
        try:
            poem = yield get_poetry(host, port)
        except Exception, e:
            print &gt;&gt;sys.stderr, 'The poem download failed:', e
            raise

        try:
            poem = yield proxy.xform('cummingsify', poem)
        except Exception:
            print &gt;&gt;sys.stderr, 'Cummingsify failed!'

        defer.returnValue(poem)

   def got_poem(poem):
       print poem

   def poem_done(_):
       results.append(_)
       if len(results) == len(addresses):
           reactor.stop()

   for address in addresses:
       host, port = address
       d = get_transformed_poem(host, port)
       d.addCallbacks(got_poem)
       d.addBoth(poem_done)

   reactor.run()</pre>
</div>
<p>在这个新版本里, <tt class="docutils literal"><span class="pre">inlineCallbacks</span></tt> 生成函数 <cite>get_transformed_poem</cite> 负责取回诗歌并且应用变换(通过变换服务).由于这两个操作都是异步的,我们每次生成一个 <tt class="docutils literal"><span class="pre">deferred</span></tt> 并且隐式地等待结果.与客户端6.0一样,如果变换失败则返回原始诗歌.我们可以使用 <tt class="docutils literal"><span class="pre">try/except</span></tt> 语句捕获生成器中的异步错误.</p>
<p>我们以先前的方式测试新版客户端. 首先启动一个变换服务:</p>
<div class="highlight-python"><pre>python twisted-server-1/tranformedpoetry.py --port 10001</pre>
</div>
<p>然后启动两个诗歌服务器:</p>
<div class="highlight-python"><pre>python twisted-server-1/fastpoetry.py --port 10002 poetry/fascination.txt
python twisted-server-1/fastpoetry.py --port 10003 poetry/science.txt</pre>
</div>
<p>现在可以运行新的客户端:</p>
<div class="highlight-python"><pre>python twisted-client-7/get-poetry.py 10001 10002 10003</pre>
</div>
<p>试试关闭一个或多个服务器,看一看客户端如何捕获错误.</p>
</div>
<div class="section" id="id7">
<h3>讨论<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>就像 <tt class="docutils literal"><span class="pre">Deferred</span></tt> 对象, <tt class="docutils literal"><span class="pre">inlineCallbacks</span></tt> 函数给我们一种组织异步回调的新方式.同时,如同使用 <tt class="docutils literal"><span class="pre">deferred</span></tt>, <tt class="docutils literal"><span class="pre">inllineCallbacks</span></tt> 没有改变游戏规则.特别地,我们的回调仍然一次调用一个回调,它们仍然被 <tt class="docutils literal"><span class="pre">reactor</span></tt> 调用.我们可以通过打印内联回调的回溯跟踪信息来证实这一点,参见脚本 <a class="reference external" href="https://github.com/jdavisp3/twisted-intro/blob/master/inline-callbacks/inline-callbacks-tb.py#L1">inline-callbacks/inline-callbacks-tb.py</a>.运行此代码你将首先获得一个关于 <cite>reactor.run()</cite> 的回溯,然后是许多帮助函数信息,最后是我们的回调.</p>
<p>图29解释了当 <tt class="docutils literal"><span class="pre">deferred</span></tt> 中一个回调返回另一个 <tt class="docutils literal"><span class="pre">deferred</span></tt> 时会发生什么,我们调整它来展示当一个 <tt class="docutils literal"><span class="pre">inlineCallbacks</span></tt> 生成器生成一个 <tt class="docutils literal"><span class="pre">deferred</span></tt> 时会发生什么,参考图36:</p>
<div class="figure" id="figure36">
<img alt="_images/p17_inline-callbacks1.png" src="_images/p17_inline-callbacks1.png" />
</div>
<div class="line-block">
<div class="line">图36: <tt class="docutils literal"><span class="pre">inlineCallbacks</span></tt> 函数中的控制流</div>
</div>
<p>同样的图对两种情况都适用,因为它们表示的想法都是一样的 —— 一个异步操作正在等待另一个.</p>
<p>由于 <tt class="docutils literal"><span class="pre">inlineCallbacks</span></tt> 和 <tt class="docutils literal"><span class="pre">deferred</span></tt> 解决许多相同的问题,在它们之间如何选择呢?下面列出一些 <tt class="docutils literal"><span class="pre">inlineCallbacks</span></tt> 的潜在优势.</p>
<ul class="simple">
<li>由于回调分享相同的名空间,因此没有必要传递额外状态.</li>
<li>回调的顺序很容易看到,因为它总是从上到下执行.</li>
<li>节省了每个回调函数的声明和隐式控制流,通常减少输入.</li>
<li>可以使用熟悉的 <cite>try/except</cite> 语句处理错误.</li>
</ul>
<p>当然也存在一些缺陷:</p>
<ul class="simple">
<li>生成器中的回调不能被单独调用,这使代码重用比较困难.而构造 <tt class="docutils literal"><span class="pre">deferred</span></tt> 的代码则能够以任意顺序自由地添加任何回调.</li>
<li>生成器的紧致性可能混淆一个事实,其实异步回调非常晦涩.尽管生成器看起来像一个普通的函数序列,但是它的行为却非常不一样. <tt class="docutils literal"><span class="pre">inlineCallbacks</span></tt> 函数不是一种避免学习异步编程模型的方式.</li>
</ul>
<p>就像任何技术,实践将积累出必要的经验,帮你做出明智选择.</p>
</div>
<div class="section" id="id8">
<h3>总结<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>在这个部分,我们学习了 <tt class="docutils literal"><span class="pre">inlineCallbacks</span></tt> 装饰符以及它怎样使我们能够以Python生成器的形式表达一系列异步回调.</p>
<p>在 <a class="reference internal" href="p18.html"><em>第十八部分 Deferreds 全貌</em></a> 中,我们将学习一种管理 <strong>一组</strong> &#8220;并行&#8221;异步操作的技术.</p>
</div>
<div class="section" id="id9">
<h3>参考练习<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<ol class="arabic simple">
<li>为什么 <tt class="docutils literal"><span class="pre">inlineCallbacks</span></tt> 函数是复数(形式)?</li>
<li>研究 <a class="reference external" href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-10.1.0/twisted/internet/defer.py#973">inlineCallbacks</a> 的实现以及它们帮助函数 <a class="reference external" href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-10.1.0/twisted/internet/defer.py#L874">_inlineCallbacks</a>. 并思考短语&#8221;魔鬼在细节处&#8221;.</li>
<li>有N个 <tt class="docutils literal"><span class="pre">yield</span></tt> 语句的生成器中包含多少个回调,假设其中没有循环或者 <tt class="docutils literal"><span class="pre">if</span></tt> 语句?</li>
<li>诗歌客户端7.0可能同时运行三个生成器.概念上,它们之间有多少种不同的交错方式?考虑诗歌客户端和 <tt class="docutils literal"><span class="pre">inlineCallbacks</span></tt> 的实现,你认为实际有多少种可能?</li>
<li>把客户端7.0中的 <cite>got_poem</cite> 放入到生成器中.</li>
<li>把 <cite>poem_done</cite> 回调放入生成器.小心!确保处理所有失败情况以便无论怎样 <tt class="docutils literal"><span class="pre">reactor</span></tt> 都会关闭.与使用 <tt class="docutils literal"><span class="pre">deferred</span></tt> 关闭 <tt class="docutils literal"><span class="pre">reactor</span></tt> 对比代码有何不同?</li>
<li>一个在 <tt class="docutils literal"><span class="pre">while</span></tt> 循环中使用 <tt class="docutils literal"><span class="pre">yield</span></tt> 语句的生成器代表一个概念上的无限序列.那么同样的装饰有 <tt class="docutils literal"><span class="pre">inlineCallbacks</span></tt> 的生成器又代表什么呢?</li>
</ol>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="p16.html">第十六部分 Twisted 进程守护</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">目录</a>
        &#160;&#160;::&#160;&#160;
        <a href="p18.html">第十八部分 Deferreds 全貌</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; 版权所有 2011, Cheng Luo.
      最后更新日期是 Sep 04, 2013.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>